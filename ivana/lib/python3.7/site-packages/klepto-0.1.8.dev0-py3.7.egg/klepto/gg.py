
import pickle

def _create_newobj(cls, args, kwargs, extra):
    new_obj =  cls.__new__(cls, *args, **kwargs)
    print('get new obj')
    for key, val in extra.items():
        setattr(new_obj, key, val)
    return new_obj


class Blubb(object):

    def __init__(self, value, foo=None, bar=None):
        self.value = value
        self.foo = foo
        self.bar = bar
    
        def __reduce_ex__(self, protocol):
            extra = {}
            _dict = getattr(self, '__dict__', None)
            if _dict is not None:
                extra['__dict__'] = _dict
            _slots = getattr(self, '__slots__', None)
            if _slots is not None:
                extra['__slots__'] = _slots
                for slot in _slots:
                    try:
                        extra[slot] = getattr(self, slot)
                    except AttributeError:
                        pass
            self.__newargs__ = (self.value,)
            self.__newkwargs__ = {'foo': self.foo, 'bar': self.bar}
            return (
                _create_newobj, 
                (self.__class__, self.__newargs__, self.__newkwargs__, extra), None, None, None)

def _new_Bla(cls, value, kw):
    "A function to map kwargs into cls.__new__"
    return cls.__new__(cls, value, **kw)

class Bla(Blubb):

    def __new__(cls, value, **kw):
        instance = super(Bla, cls).__new__(cls)
        instance.__init__(value, **kw)
        return instance

    def __reduce__(self):
        kwargs = {'foo': self.foo, 'bar': self.bar}
        return _new_Bla, (self.__class__, self.value, kwargs), None

x = Blubb(2, bar=[1, 2, 3])
pickled = pickle.dumps(x, 2)
y = pickle.loads(pickled)
assert y.value == 2
assert y.bar == [1, 2, 3]